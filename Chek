
from asyncio import wait_for

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import NoSuchElementException
import time


class WildberriesReviewParser:
    def __init__(self):
        self.driver = webdriver.Chrome()
        self.reviews_data = []

    def parse_reviews(self, product_url):
        self.driver.get(product_url)


        # Ждем загрузки отзывов
        wait = WebDriverWait(self.driver, 10)

        try:
            reviews_section = wait.until(
                EC.presence_of_element_located((By.CLASS_NAME, "comments__list"))
            )
        except:
            print("Не удалось найти блок с отзывами")
            return []
        k = 0
        while k <= 5:

            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")

            time.sleep(1)
            k += 1

        # Собираем все отзывы на странице
        review_elements = self.driver.find_elements(By.CLASS_NAME, "comments__item")

        for review in review_elements:
            review_data = self.extract_review_data(review)
            if review_data:
                self.reviews_data.append(review_data)

        return self.reviews_data

    def extract_review_data(self, review_element):
        try:
            # Извлекаем имя пользователя
            username = self.get_username(review_element)

            # Извлекаем текст отзыва
            review_text = self.get_review_text(review_element)

            # Извлекаем оценку
            rating = self.get_rating(review_element)



            return {
                'username': username,
                'review_text': review_text,
                'rating': rating,
            }

        except Exception as e:
            print(f"Ошибка при парсинге отзыва: {e}")
            return None

    def get_username(self, element):
        try:
            # Ищем имя пользователя
            username_element = element.find_element(By.CLASS_NAME, "feedback__header")
            return username_element.text.strip()
        except NoSuchElementException:
            return "Аноним"

    def get_rating(self, element):
        try:
            # Ищем блок с рейтингом
            rating_element = element.find_element(By.CSS_SELECTOR, ".feedback__top-wrap .feedback__info .feedback__wrap .feedback__rating-wrap .feedback__rating")

            classes = rating_element.get_attribute("class").split()

            for cls in classes:
                if cls.startswith("star") and cls[4:].isdigit():
                    return int(cls[4:])
            return 0
        except NoSuchElementException:
            return 0

    def get_review_text(self, element):
        try:
            text_element = element.find_element(By.CSS_SELECTOR, ".feedback__text.j-feedback__text")
            return text_element.text.strip()
        except NoSuchElementException:
            return ""


    def close(self):
        self.driver.quit()


if __name__ == "__main__":
    parser = WildberriesReviewParser()

    try:
        #  Теперь переменная определена ДО использования
        product_url = "https://www.wildberries.ru/catalog/31299196/feedbacks?imtId=508083781&size=68237787"

        # Парсим отзывы
        reviews = parser.parse_reviews(product_url)  # Передаем URL как аргумент
        # Выводим результаты
        i = 1

        if reviews:
            for i, review in enumerate(reviews, 1):
                print(f"Отзыв #{i}:")
                print(f"  Пользователь: {review['username']}")
                print(f"  Оценка: {review['rating']}/5")
                print(f"  Текст: {review['review_text']}")
                print("-" * 50)
                i += 1

        else:
             print("Отзывы не найдены")

        # Сохраняем в Excel

    except Exception as e:
        print(f"Произошла ошибка: {e}")
    finally:
        parser.close()





